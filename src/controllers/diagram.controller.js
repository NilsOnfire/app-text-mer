const e = require('express');
const { generatePrompt, ChatGPT } = require('../utils/diagram');

/**
 * 
 * @param {e.Request} req 
 * @param {e.Response} res 
 */
exports.generateDiagram = (req, res) => {
    const input = req.body.text.toString();
    console.log(input)
    res.status(200).json({ message: input })
    // const chat = new ChatGPT();

    // let prompt = chat.generatePrompt(input);

    // // asyncronic function  to wait the result generated by gpt
    // const chapGPT = async (stm, prompt) => {
    //     // Chat-gpt connection

    //     const openai = chat.getOpenAI();

    //     const response = await openai.createChatCompletion({
    //         model: "gpt-3.5-turbo",
    //         messages: [{ role: "user", content: prompt }],
    //     });

    //     //Get data generated by chatgpt from prompt

    //     let completion = response["data"]["choices"][0]["message"]["content"];
    //     console.log(completion)

    //     //Retrieving data by creating mermaid code format erDiagram
    //     completion = `${completion}`;

    //     //converting to js object
    //     const objectMer = JSON.parse(completion);

    //     //Separating entities and relationships
    //     const listOfkeys = Object.keys(objectMer);
    //     const listOfRels = [];
    //     const listOfEntities = [];

    //     listOfkeys.forEach((element) => {
    //         if (objectMer[element]["cardinalidad"]) {
    //             listOfRels.push(element);
    //         } else {
    //             listOfEntities.push(element);
    //         }
    //     });

    //     //functions to convert data in mermaid code ER format
    //     let entities = converter.getEntitiesWithAttribs(objectMer, listOfEntities);
    //     let rels = converter.getRelations(objectMer, listOfRels);
    //     completion = entities + "\n" + rels;
    //     console.log(completion);

    //     var data = { texts: { resp: completion, title: "TextMer", stm } };
    //     console.log(typeof completion);
    //     res.status(200).json({ response: data });
    // };

    // chapGPT(input, prompt);
};